use std::{collections::BTreeMap, env, fs, path::PathBuf};

use serde::Deserialize;
use sha2::{Digest, Sha256};

#[derive(Debug, Deserialize)]
struct OpenApiDoc {
    paths: BTreeMap<String, BTreeMap<String, Operation>>,
}

#[derive(Debug, Deserialize)]
struct Operation {
    #[serde(rename = "operationId")]
    operation_id: Option<String>,
}

fn method_name(path: &str, method: &str, operation_id: Option<&str>) -> String {
    if let Some(operation_id) = operation_id {
        let mut out = String::new();
        for (index, ch) in operation_id.chars().enumerate() {
            if ch.is_ascii_uppercase() {
                if index > 0 {
                    out.push('_');
                }
                out.push(ch.to_ascii_lowercase());
            } else {
                out.push(ch);
            }
        }
        return out;
    }

    let mut name = String::new();
    name.push_str(method);
    name.push('_');
    for ch in path.chars() {
        if ch.is_ascii_alphanumeric() {
            name.push(ch.to_ascii_lowercase());
        } else {
            name.push('_');
        }
    }

    while name.contains("__") {
        name = name.replace("__", "_");
    }
    name.trim_matches('_').to_string()
}

fn main() {
    let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR"));
    let spec_path = manifest_dir.join("../../../openapi.yaml");
    println!("cargo:rerun-if-changed={}", spec_path.display());

    let spec_raw = fs::read_to_string(&spec_path).expect("failed to read openapi.yaml");
    let spec_hash = format!("{:x}", Sha256::digest(spec_raw.as_bytes()));
    let parsed: OpenApiDoc = serde_yaml::from_str(&spec_raw).expect("invalid openapi.yaml");

    let mut lines = Vec::new();
    lines.push("// @generated by contracts/rust/api_contract/build.rs".to_string());
    lines.push(format!(
        "pub const OPENAPI_SHA256: &str = \"{}\";",
        spec_hash
    ));
    lines.push("pub trait EpochApiContract {".to_string());

    for (path, methods) in parsed.paths {
        for (http_method, operation) in methods {
            let method = method_name(&path, &http_method, operation.operation_id.as_deref());
            lines.push(format!("    fn {}(&self);", method));
        }
    }

    lines.push("}".to_string());
    lines.push("".to_string());
    lines.push("pub fn operation_names() -> &'static [&'static str] {".to_string());
    lines.push("    &[".to_string());

    let parsed: OpenApiDoc = serde_yaml::from_str(&spec_raw).expect("invalid openapi.yaml");
    for (path, methods) in parsed.paths {
        for (http_method, operation) in methods {
            let method = method_name(&path, &http_method, operation.operation_id.as_deref());
            lines.push(format!("        \"{}\",", method));
        }
    }

    lines.push("    ]".to_string());
    lines.push("}".to_string());

    let out_dir = PathBuf::from(env::var("OUT_DIR").expect("OUT_DIR"));
    fs::write(out_dir.join("generated_contract.rs"), lines.join("\n"))
        .expect("failed to write generated contract");
}
